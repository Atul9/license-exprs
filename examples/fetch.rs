// `error_chain!` can recurse deeply
#![recursion_limit = "1024"]

#[macro_use]
extern crate error_chain;
extern crate futures;
extern crate hyper;
extern crate hyper_tls;
extern crate native_tls;
extern crate serde_json;
extern crate tokio_core;

use std::io::{self, Write};
use std::{env, process};

use futures::{future, Future, Stream};
use hyper::Client;
use hyper_tls::HttpsConnector;
use serde_json::Value;
use serde_json::map::Map;
use tokio_core::reactor::Core;

// We'll put our errors in a `errors` module
mod errors {
    // Create the Error, ErrorKind, ResultExt, and Result types
    #[allow(unused_doc_comment)]
    error_chain!{
        // Automatic conversions between this error chain and other
        // error types not defined by the `error_chain!`.
        foreign_links {
            IO(::std::io::Error);
            TLS(::native_tls::Error);
            URI(::hyper::error::UriError);
            Hyper(::hyper::error::Error);
            JSON(::serde_json::Error);
        }
    }
}

fn download<F>(core: &mut Core, uri: &str, mut action: F, debug: bool) -> errors::Result<()>
    where F: FnMut(Map<String, Value>) -> errors::Result<()> {
    let handle = core.handle();
    let c = Client::configure().connector(HttpsConnector::new(4, &handle)?).build(&handle);
    let future = c.get(uri.parse()?).and_then(|res| {
        future::result(if debug {
            writeln!(io::stderr(), "Response: {}", res.status())
        } else { Ok(()) }.map_err(|e| e.into())).and_then(|_| {
            res.body().concat2()})});
    let res = core.run(future)?;

    let json: Value = serde_json::from_slice(&res)?;
    let json = if let Value::Object(m) = json {
        m
    } else {
        return Err(io::Error::new(io::ErrorKind::Other, format!("Malformed JSON: {:?}", json)).into())
    };

    if debug {
        writeln!(io::stderr(), "#json == {}", json.len())?;
        writeln!(io::stderr(), "License list version {}", json["licenseListVersion"])?;
    }
    action(json)
}

fn main1(args: &[String]) -> errors::Result<()> {
    let mut upstream_tag = "master";
    let mut debug = false;
    for e in args {
        match e.as_str() {
            "-d" => {
                debug = true;
            },
            s if s.starts_with('v') => {
                upstream_tag = &s;
            },
            _ => {
                bail!("Unknown option {:?}", e)
            }
        }
    }

    let mut stdout = io::stdout();
    let mut stderr = io::stderr();

    if upstream_tag == "master" {
        writeln!(stderr, "WARN: fetching data from the master branch of spdx/license-list-data; \
                          consider specifying a tag (e.g. v3.0)")?;
    } else {
        writeln!(stderr, "Using tag {:?}", upstream_tag)?;
    }

    writeln!(stdout, "\
/*
 * whitelist fetched from https://github.com/spdx/license-list-data
 *
 * AUTO-GENERATED BY examples/fetch.rs
 * DO NOT MODIFY
 *
 * cargo run --example fetch-license-list-from-spdx v3.0 > spdx.rs
 */
")?;

    let mut core = Core::new()?;

    let licenses_json_uri =
        format!("https://raw.githubusercontent.com/spdx/license-list-data/{}/json/licenses.json",
                upstream_tag);
    download(&mut core, &licenses_json_uri, |json| {
        let licenses = if let Value::Array(ref v) = json["licenses"] {
            v
        } else {
            bail!("Malformed JSON: {:?}", json["licenses"])
        };
        writeln!(stderr, "#licenses == {}", licenses.len())?;

        let mut v = vec![];
        for lic in licenses.iter() {
            let lic = if let Value::Object(ref m) = *lic {
                m
            } else {
                bail!("Malformed JSON: {:?}", lic)
            };
            if debug {
                writeln!(stderr, "{},{}",
                    lic.get("licenseId").unwrap_or(&Value::String("missing licenseId".into())),
                    lic.get("name").unwrap_or(&Value::String("missing name".into())))?;
            }

            if let Some(id) = lic.get("licenseId") {
                if let Value::String(ref s) = *id {
                    v.push(s);
                } else {
                    bail!("Malformed JSON: {:?}", id);
                }
            }
        }
        v.sort();

        writeln!(stdout, "pub const VERSION: &'static str = {};",
            json.get("licenseListVersion").ok_or("missing licenseListVersion")?)?;
        writeln!(stdout)?;
        writeln!(stdout, "pub const LICENSES: &'static [&'static str] = &[")?;
        for lic in v.iter() {
            writeln!(stdout, "    \"{}\",", lic)?;
        }
        writeln!(stdout, "];")?;

        Ok(())
    }, debug)?;

    writeln!(stdout)?;

    let exceptions_json_uri =
        format!("https://raw.githubusercontent.com/spdx/license-list-data/{}/json/exceptions.json",
                upstream_tag);
    download(&mut core, &exceptions_json_uri, |json| {
        let exceptions = if let Value::Array(ref v) = json["exceptions"] {
            v
        } else {
            bail!("Malformed JSON: {:?}", json["exceptions"])
        };
        writeln!(stderr, "#exceptions == {}", exceptions.len())?;

        let mut v = vec![];
        for exc in exceptions.iter() {
            let exc = if let Value::Object(ref m) = *exc {
                m
            } else {
                bail!("Malformed JSON: {:?}", exc)
            };
            if debug {
                writeln!(io::stderr(), "{},{}", exc["licenseExceptionId"], exc["name"])?;
            }

            if let Value::String(ref s) = exc["licenseExceptionId"] {
                v.push(s);
            } else {
                bail!("Malformed JSON: {:?}", exc["licenseExceptionId"])
            };
        }

        writeln!(stdout, "pub const EXCEPTIONS: &'static [&'static str] = &[")?;
        v.sort();
        for exc in v.iter() {
            writeln!(stdout, "    \"{}\",", exc)?;
        }
        writeln!(stdout, "];")?;

        Ok(())
    }, debug)?;

    Ok(())
}

fn main() {
    let args = env::args().skip(1).collect::<Vec<_>>();
    if let Err(ref e) = main1(args.as_ref()) {
        use error_chain::ChainedError; // trait which holds `display_chain`

        writeln!(io::stderr(), "{}", e.display_chain()).expect("writeln to stderr");
        process::exit(1);
    }
}
